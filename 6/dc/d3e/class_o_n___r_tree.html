<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.8.13"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>openNURBS SDK Help: ON_RTree Class Reference</title>
  <link href="../../tabs.css" rel="stylesheet" type="text/css"/>
  <!-- <script type="text/javascript" src="../../jquery.js"></script> -->
  <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script type="text/javascript" src="../../dynsections.js"></script>
  <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
  <link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
  <!-- smartmenus -->
  <link href="../../jquery.smartmenus.bootstrap.css" rel="stylesheet">
  <script type="text/javascript" src="../../jquery.smartmenus.js"></script>
  <script type="text/javascript" src="../../jquery.smartmenus.bootstrap.js"></script>
</head>
<body>
  <!-- navbar -->
  <div class="navbar navbar-default navbar-static top" role="navigation">
    <div class="navbar-header">
      <a class="navbar-brand">openNURBS SDK Help 6.0</a>
    </div>
  </div>
  <div class="container">
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="page-content">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="../../da/de3/class_o_n___r_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_RTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d9/df9/opennurbs__rtree_8h_source.html">opennurbs_rtree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f3ce6431eb6d69c4f8d82b473979147"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a6f3ce6431eb6d69c4f8d82b473979147">ON_RTree</a> (size_t leaf_count=0)</td></tr>
<tr class="separator:a6f3ce6431eb6d69c4f8d82b473979147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc1ab729e917fa616de40980fea494b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a3bc1ab729e917fa616de40980fea494b">~ON_RTree</a> ()</td></tr>
<tr class="separator:a3bc1ab729e917fa616de40980fea494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf66798ce1ab81e70c4d2ad971db1117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d17/class_o_n___bounding_box.html">ON_BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#acf66798ce1ab81e70c4d2ad971db1117">BoundingBox</a> () const</td></tr>
<tr class="separator:acf66798ce1ab81e70c4d2ad971db1117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaa332119e0045797d276cf5d593dc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#aeaaa332119e0045797d276cf5d593dc2">CreateMeshFaceTree</a> (const class <a class="el" href="../../df/d11/class_o_n___mesh.html">ON_Mesh</a> *mesh)</td></tr>
<tr class="memdesc:aeaaa332119e0045797d276cf5d593dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an R-tree with an element for each face in the mesh. The element id is set to the index of the face.  <a href="#aeaaa332119e0045797d276cf5d593dc2">More...</a><br /></td></tr>
<tr class="separator:aeaaa332119e0045797d276cf5d593dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553c28a6189ab8b336aad9d0cc5d1ae1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a553c28a6189ab8b336aad9d0cc5d1ae1">ElementCount</a> ()</td></tr>
<tr class="separator:a553c28a6189ab8b336aad9d0cc5d1ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de21d768597267474047dda81932e2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a9de21d768597267474047dda81932e2c">Insert</a> (const double a_min[3], const double a_max[3], void *a_element_id)</td></tr>
<tr class="memdesc:a9de21d768597267474047dda81932e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into the RTree.  <a href="#a9de21d768597267474047dda81932e2c">More...</a><br /></td></tr>
<tr class="separator:a9de21d768597267474047dda81932e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de2fc8ec53bfbda3eb7ebbbc88d4134"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a8de2fc8ec53bfbda3eb7ebbbc88d4134">Insert</a> (const double a_min[3], const double a_max[3], int a_element_id)</td></tr>
<tr class="separator:a8de2fc8ec53bfbda3eb7ebbbc88d4134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97725a6bd12416b8239635208ba80630"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a97725a6bd12416b8239635208ba80630">Insert2d</a> (const double a_min[2], const double a_max[2], void *a_element_id)</td></tr>
<tr class="separator:a97725a6bd12416b8239635208ba80630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa006eb044d4bc8f134d1bf7a0be6cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a6aa006eb044d4bc8f134d1bf7a0be6cf">Insert2d</a> (const double a_min[2], const double a_max[2], int a_element_id)</td></tr>
<tr class="separator:a6aa006eb044d4bc8f134d1bf7a0be6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dad8a204492af25fd33fb1fde74758"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#aa1dad8a204492af25fd33fb1fde74758">Remove</a> (const double a_min[3], const double a_max[3], void *a_elementId)</td></tr>
<tr class="memdesc:aa1dad8a204492af25fd33fb1fde74758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from the RTree.  <a href="#aa1dad8a204492af25fd33fb1fde74758">More...</a><br /></td></tr>
<tr class="separator:aa1dad8a204492af25fd33fb1fde74758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1e12e01dc16b1a0b550a71497f0482"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#afc1e12e01dc16b1a0b550a71497f0482">Remove</a> (const double a_min[3], const double a_max[3], int a_elementId)</td></tr>
<tr class="separator:afc1e12e01dc16b1a0b550a71497f0482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa597272cc74d45a57a9049350329c44e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#aa597272cc74d45a57a9049350329c44e">Remove2d</a> (const double a_min[2], const double a_max[2], void *a_elementId)</td></tr>
<tr class="separator:aa597272cc74d45a57a9049350329c44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae800b17ab98147356110941ef0f72ecb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#ae800b17ab98147356110941ef0f72ecb">Remove2d</a> (const double a_min[2], const double a_max[2], int a_elementId)</td></tr>
<tr class="separator:ae800b17ab98147356110941ef0f72ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46db5e9d84bc480f1fa7550b09e1fbd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a46db5e9d84bc480f1fa7550b09e1fbd1">RemoveAll</a> ()</td></tr>
<tr class="memdesc:a46db5e9d84bc480f1fa7550b09e1fbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from the R-tree.  <a href="#a46db5e9d84bc480f1fa7550b09e1fbd1">More...</a><br /></td></tr>
<tr class="separator:a46db5e9d84bc480f1fa7550b09e1fbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2e00cbb7018e8ebce40218565ae0f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../de/d18/struct_o_n___r_tree_node.html">ON_RTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#adc2e00cbb7018e8ebce40218565ae0f2">Root</a> () const</td></tr>
<tr class="separator:adc2e00cbb7018e8ebce40218565ae0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8689767a0edbccf8ff7181f7b0af9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a3c8689767a0edbccf8ff7181f7b0af9b">Search</a> (<a class="el" href="../../d3/d7f/struct_o_n___r_tree_sphere.html">ON_RTreeSphere</a> *a_sphere, bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_id), void *a_context) const</td></tr>
<tr class="memdesc:a3c8689767a0edbccf8ff7181f7b0af9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the R-tree for all elements whose bounding boxes overlap a_rect.  <a href="#a3c8689767a0edbccf8ff7181f7b0af9b">More...</a><br /></td></tr>
<tr class="separator:a3c8689767a0edbccf8ff7181f7b0af9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178196eaa2fd6ca8317f62a13d853817"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a178196eaa2fd6ca8317f62a13d853817">Search</a> (<a class="el" href="../../df/d46/struct_o_n___r_tree_capsule.html">ON_RTreeCapsule</a> *a_capsule, bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_id), void *a_context) const</td></tr>
<tr class="separator:a178196eaa2fd6ca8317f62a13d853817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93488df03e8d43bf059881bb2dcfba93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a93488df03e8d43bf059881bb2dcfba93">Search</a> (<a class="el" href="../../da/dce/struct_o_n___r_tree_b_box.html">ON_RTreeBBox</a> *a_rect, bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_id), void *a_context) const</td></tr>
<tr class="separator:a93488df03e8d43bf059881bb2dcfba93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384a71567ae0e7f0b55acd0548fb1fd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a384a71567ae0e7f0b55acd0548fb1fd6">Search</a> (const double a_plane_eqn[4], double a_min, double a_max, bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_id), void *a_context) const</td></tr>
<tr class="memdesc:a384a71567ae0e7f0b55acd0548fb1fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the R-tree for all elements whose bounding boxes overlap the set of points between to parallel planes.  <a href="#a384a71567ae0e7f0b55acd0548fb1fd6">More...</a><br /></td></tr>
<tr class="separator:a384a71567ae0e7f0b55acd0548fb1fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb48a60f59ea578c30939e1c45d1829e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#aeb48a60f59ea578c30939e1c45d1829e">Search</a> (const class <a class="el" href="../../dd/d89/class_o_n___plane_equation.html">ON_PlaneEquation</a> &amp;a_plane_eqn, double a_min, double a_max, bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_id), void *a_context) const</td></tr>
<tr class="separator:aeb48a60f59ea578c30939e1c45d1829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f871f48b5e1ad3deeb8ac1b95921f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#ab4f871f48b5e1ad3deeb8ac1b95921f9">Search</a> (const double a_min[3], const double a_max[3], bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_id), void *a_context) const</td></tr>
<tr class="separator:ab4f871f48b5e1ad3deeb8ac1b95921f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14df7f1392e2f2c98ad5d4ced530187e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a14df7f1392e2f2c98ad5d4ced530187e">Search</a> (const double a_min[3], const double a_max[3], <a class="el" href="../../d4/d7d/struct_o_n___r_tree_search_result.html">ON_RTreeSearchResult</a> &amp;a_result) const</td></tr>
<tr class="separator:a14df7f1392e2f2c98ad5d4ced530187e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad04555e76f86ddd5359ceb6948a7df7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#aad04555e76f86ddd5359ceb6948a7df7">Search</a> (const double a_min[3], const double a_max[3], <a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="../../db/d66/struct_o_n___r_tree_leaf.html">ON_RTreeLeaf</a> &gt; &amp;a_result) const</td></tr>
<tr class="separator:aad04555e76f86ddd5359ceb6948a7df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2149ea0203541285b3d5ca3c2c57c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a3b2149ea0203541285b3d5ca3c2c57c3">Search</a> (const double a_min[3], const double a_max[3], <a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; void *&gt; &amp;a_result) const</td></tr>
<tr class="separator:a3b2149ea0203541285b3d5ca3c2c57c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18942534add216538d971d266ef62f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#ae18942534add216538d971d266ef62f3">Search</a> (const double a_min[3], const double a_max[3], <a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;a_result) const</td></tr>
<tr class="separator:ae18942534add216538d971d266ef62f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691a5c09301cf8a7f869f762f9b51dc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a691a5c09301cf8a7f869f762f9b51dc8">Search</a> (double tolerance, <a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; ON_2dex &gt; &amp;a_result) const</td></tr>
<tr class="memdesc:a691a5c09301cf8a7f869f762f9b51dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a single R-tree for all pairs of distinct elements whose bounding boxes overlap.  <a href="#a691a5c09301cf8a7f869f762f9b51dc8">More...</a><br /></td></tr>
<tr class="separator:a691a5c09301cf8a7f869f762f9b51dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cffce7ab9b169a55f95f5a305299531"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a7cffce7ab9b169a55f95f5a305299531">Search</a> (double tolerance, void ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB), void *a_context) const</td></tr>
<tr class="memdesc:a7cffce7ab9b169a55f95f5a305299531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a single R-tree for all pairs of distinct elements whose bounding boxes overlap.  <a href="#a7cffce7ab9b169a55f95f5a305299531">More...</a><br /></td></tr>
<tr class="separator:a7cffce7ab9b169a55f95f5a305299531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce5797e0f24dcfe60e4cb5d2a305551"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a7ce5797e0f24dcfe60e4cb5d2a305551">Search</a> (double tolerance, bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB), void *a_context) const</td></tr>
<tr class="memdesc:a7ce5797e0f24dcfe60e4cb5d2a305551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a single R-tree for all pairs of distinct elements whose bounding boxes overlap.  <a href="#a7ce5797e0f24dcfe60e4cb5d2a305551">More...</a><br /></td></tr>
<tr class="separator:a7ce5797e0f24dcfe60e4cb5d2a305551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86bf57453293f572bb791c449b23cdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#ae86bf57453293f572bb791c449b23cdb">Search</a> (double tolerance, bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB, double *tolerance), void *a_context) const</td></tr>
<tr class="memdesc:ae86bf57453293f572bb791c449b23cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a single R-tree for all pairs of distinct elements whose bounding boxes overlap.  <a href="#ae86bf57453293f572bb791c449b23cdb">More...</a><br /></td></tr>
<tr class="separator:ae86bf57453293f572bb791c449b23cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b64597a8b7cb18ec70db91613bc198"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a25b64597a8b7cb18ec70db91613bc198">Search2d</a> (const double a_min[2], const double a_max[2], bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_id), void *a_context) const</td></tr>
<tr class="separator:a25b64597a8b7cb18ec70db91613bc198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183fe6167390c34f7ddf4346c815d3f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a183fe6167390c34f7ddf4346c815d3f3">Search2d</a> (const double a_min[2], const double a_max[2], <a class="el" href="../../d4/d7d/struct_o_n___r_tree_search_result.html">ON_RTreeSearchResult</a> &amp;a_result) const</td></tr>
<tr class="separator:a183fe6167390c34f7ddf4346c815d3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12daf0578b650d8fb176c6bfd0551ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#ac12daf0578b650d8fb176c6bfd0551ea">Search2d</a> (const double a_min[2], const double a_max[2], <a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="../../db/d66/struct_o_n___r_tree_leaf.html">ON_RTreeLeaf</a> &gt; &amp;a_result) const</td></tr>
<tr class="separator:ac12daf0578b650d8fb176c6bfd0551ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0796e641e7182e2627dc603934de7cac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a0796e641e7182e2627dc603934de7cac">Search2d</a> (const double a_min[2], const double a_max[2], <a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; void *&gt; &amp;a_result) const</td></tr>
<tr class="separator:a0796e641e7182e2627dc603934de7cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4385c53c34dcf30080c8db40417352d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a4385c53c34dcf30080c8db40417352d2">Search2d</a> (const double a_min[2], const double a_max[2], <a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;a_result) const</td></tr>
<tr class="separator:a4385c53c34dcf30080c8db40417352d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafee383d7c1af961a7608376d7ce7154"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#aafee383d7c1af961a7608376d7ce7154">SizeOf</a> () const</td></tr>
<tr class="separator:aafee383d7c1af961a7608376d7ce7154"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a89495554a3643a1ceccf18fc3de4028f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a89495554a3643a1ceccf18fc3de4028f">Search</a> (const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;a_rtreeA, const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;a_rtreeB, double tolerance, <a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; ON_2dex &gt; &amp;a_result)</td></tr>
<tr class="memdesc:a89495554a3643a1ceccf18fc3de4028f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search two R-trees for all pairs elements whose bounding boxes overlap.  <a href="#a89495554a3643a1ceccf18fc3de4028f">More...</a><br /></td></tr>
<tr class="separator:a89495554a3643a1ceccf18fc3de4028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305a82abc47dd0a6ea8ee89b06cf37da"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a305a82abc47dd0a6ea8ee89b06cf37da">Search</a> (const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;a_rtreeA, const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;a_rtreeB, double tolerance, void ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB), void *a_context)</td></tr>
<tr class="memdesc:a305a82abc47dd0a6ea8ee89b06cf37da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search two R-trees for all pairs elements whose bounding boxes overlap.  <a href="#a305a82abc47dd0a6ea8ee89b06cf37da">More...</a><br /></td></tr>
<tr class="separator:a305a82abc47dd0a6ea8ee89b06cf37da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81130c40694f16ecc2cf8e1652972454"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a81130c40694f16ecc2cf8e1652972454">Search</a> (const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;a_rtreeA, const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;a_rtreeB, double tolerance, bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB), void *a_context)</td></tr>
<tr class="memdesc:a81130c40694f16ecc2cf8e1652972454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search two R-trees for all pairs elements whose bounding boxes overlap.  <a href="#a81130c40694f16ecc2cf8e1652972454">More...</a><br /></td></tr>
<tr class="separator:a81130c40694f16ecc2cf8e1652972454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac293e6ba656ac6e792f4c577fb0d98c8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#ac293e6ba656ac6e792f4c577fb0d98c8">Search</a> (const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;a_rtreeA, const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;a_rtreeB, double tolerance, bool ON_CALLBACK_CDECL resultCallback(void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB, double *tolerance), void *a_context)</td></tr>
<tr class="memdesc:ac293e6ba656ac6e792f4c577fb0d98c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search two R-trees for all pairs elements whose bounding boxes overlap. The tolerance can be reduced by the callback function during the search. This version of search is well suited to finding closest points between two objects.  <a href="#ac293e6ba656ac6e792f4c577fb0d98c8">More...</a><br /></td></tr>
<tr class="separator:ac293e6ba656ac6e792f4c577fb0d98c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a195f4a9b64b621cf180e09efd53fbe82"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a195f4a9b64b621cf180e09efd53fbe82">Empty</a></td></tr>
<tr class="separator:a195f4a9b64b621cf180e09efd53fbe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6f3ce6431eb6d69c4f8d82b473979147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3ce6431eb6d69c4f8d82b473979147">&#9670;&nbsp;</a></span>ON_RTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_RTree::ON_RTree </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>leaf_count</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bc1ab729e917fa616de40980fea494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc1ab729e917fa616de40980fea494b">&#9670;&nbsp;</a></span>~ON_RTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_RTree::~ON_RTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acf66798ce1ab81e70c4d2ad971db1117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf66798ce1ab81e70c4d2ad971db1117">&#9670;&nbsp;</a></span>BoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d17/class_o_n___bounding_box.html">ON_BoundingBox</a> ON_RTree::BoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Bounding box of the entire R-tree; </dd></dl>

</div>
</div>
<a id="aeaaa332119e0045797d276cf5d593dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaaa332119e0045797d276cf5d593dc2">&#9670;&nbsp;</a></span>CreateMeshFaceTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::CreateMeshFaceTree </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="../../df/d11/class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an R-tree with an element for each face in the mesh. The element id is set to the index of the face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>[in]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. </dd></dl>

</div>
</div>
<a id="a553c28a6189ab8b336aad9d0cc5d1ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553c28a6189ab8b336aad9d0cc5d1ae1">&#9670;&nbsp;</a></span>ElementCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_RTree::ElementCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of elements (leaves). Remark: No internal count is maintained, so this function traverses the tree to count the leaves. If efficiency is important, save the result. </dd></dl>

</div>
</div>
<a id="a9de21d768597267474047dda81932e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de21d768597267474047dda81932e2c">&#9670;&nbsp;</a></span>Insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Insert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_element_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element into the RTree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_min</td><td>[in]</td></tr>
    <tr><td class="paramname">a_max</td><td>[in] 3d bounding box of the element. The values in a_min[3] and a_max[3] must satisfy a_min[0] &lt;= a_max[0], a_min[1] &lt;= a_max[1], and a_min[1] &lt;= a_max[1].</td></tr>
    <tr><td class="paramname">a_dataId</td><td>[in] id of the element. This can be either a pointer or an integer id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if element was successfully inserted. </dd></dl>
<p>Calling <a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a9de21d768597267474047dda81932e2c" title="Insert an element into the RTree. ">Insert()</a> or <a class="el" href="../../dc/d3e/class_o_n___r_tree.html#aa1dad8a204492af25fd33fb1fde74758" title="Remove an element from the RTree. ">Remove()</a> invalidates any <a class="el" href="../../db/db0/class_o_n___r_tree_iterator.html">ON_RTreeIterator</a> used to iterate this rtree. </p>

</div>
</div>
<a id="a8de2fc8ec53bfbda3eb7ebbbc88d4134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de2fc8ec53bfbda3eb7ebbbc88d4134">&#9670;&nbsp;</a></span>Insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Insert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_element_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97725a6bd12416b8239635208ba80630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97725a6bd12416b8239635208ba80630">&#9670;&nbsp;</a></span>Insert2d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Insert2d </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_element_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6aa006eb044d4bc8f134d1bf7a0be6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa006eb044d4bc8f134d1bf7a0be6cf">&#9670;&nbsp;</a></span>Insert2d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Insert2d </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_element_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1dad8a204492af25fd33fb1fde74758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dad8a204492af25fd33fb1fde74758">&#9670;&nbsp;</a></span>Remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Remove </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_elementId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element from the RTree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_min</td><td>[in]</td></tr>
    <tr><td class="paramname">a_max</td><td>[in] 3d bounding box of the element. The values in a_min[3] and a_max[3] must satisfy a_min[0] &lt;= a_max[0], a_min[1] &lt;= a_max[1], and a_min[2] &lt;= a_max[2].</td></tr>
    <tr><td class="paramname">a_dataId</td><td>[in] id of the element. This can be either a pointer or an integer id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if element was successfully removed. </dd></dl>
<p>Calling <a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a9de21d768597267474047dda81932e2c" title="Insert an element into the RTree. ">Insert()</a> or <a class="el" href="../../dc/d3e/class_o_n___r_tree.html#aa1dad8a204492af25fd33fb1fde74758" title="Remove an element from the RTree. ">Remove()</a> invalidates any <a class="el" href="../../db/db0/class_o_n___r_tree_iterator.html">ON_RTreeIterator</a> used to iterate this rtree. </p>

</div>
</div>
<a id="afc1e12e01dc16b1a0b550a71497f0482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1e12e01dc16b1a0b550a71497f0482">&#9670;&nbsp;</a></span>Remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Remove </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_elementId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa597272cc74d45a57a9049350329c44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa597272cc74d45a57a9049350329c44e">&#9670;&nbsp;</a></span>Remove2d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Remove2d </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_elementId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae800b17ab98147356110941ef0f72ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae800b17ab98147356110941ef0f72ecb">&#9670;&nbsp;</a></span>Remove2d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Remove2d </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a_elementId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46db5e9d84bc480f1fa7550b09e1fbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46db5e9d84bc480f1fa7550b09e1fbd1">&#9670;&nbsp;</a></span>RemoveAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_RTree::RemoveAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements from the R-tree. </p>

</div>
</div>
<a id="adc2e00cbb7018e8ebce40218565ae0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2e00cbb7018e8ebce40218565ae0f2">&#9670;&nbsp;</a></span>Root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../de/d18/struct_o_n___r_tree_node.html">ON_RTreeNode</a>* ON_RTree::Root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root node. </dd></dl>

</div>
</div>
<a id="a3c8689767a0edbccf8ff7181f7b0af9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8689767a0edbccf8ff7181f7b0af9b">&#9670;&nbsp;</a></span>Search() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d7f/struct_o_n___r_tree_sphere.html">ON_RTreeSphere</a> *&#160;</td>
          <td class="paramname"><em>a_sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the R-tree for all elements whose bounding boxes overlap a_rect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_rect</td><td>[in/out] The version of search that has ON_RTreeBBox* a_rect as the first argument, allows you to shrink the a_rect as the search progresses. This is useful for doing things like searching for closest points. If you want to shrink a_rect, you must use a_context to pass it to the resultCallback function and shrink it in the resultCallback function. In the callback, the modified rect must be contained in the previous rect.</td></tr>
    <tr><td class="paramname">a_sphere</td><td>[in/out] The version of search that has ON_RTreeSphere* a_sphere as the first argument, allows you to shrink the a_sphere as the search progresses. This is useful for doing things like searching for closest points. If you want to shrink a_sphere, you must use a_context to pass it to the resultCallback function and shrink it in the resultCallback function. In the callback, the modified sphere must be contained in the previous sphere.</td></tr>
    <tr><td class="paramname">a_capsule</td><td>[in/out] The version of search that has ON_RTreeSphere* a_capsule as the first argument, allows you to shrink the a_capsule as the search progresses. This is useful for doing things like searching for closest points. If you want to shrink a_capsule, you must use a_context to pass it to the resultCallback function and shrink it in the resultCallback function. In the callback, the modified capsule must be contained in the previous capsule.</td></tr>
    <tr><td class="paramname">a_min</td><td>[in]</td></tr>
    <tr><td class="paramname">a_max</td><td>[in] (a_min,a_max) is the bounding box of the search region.</td></tr>
    <tr><td class="paramname">a_results</td><td>[out] The ids of elements that overlaps the search region.</td></tr>
    <tr><td class="paramname">resultCallback</td><td>[in] A function to call when leaf nodes overlap.</td></tr>
    <tr><td class="paramname">a_context</td><td>[in] pointer passed to the resultCallback() function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entire tree was searched. It is possible no results were found. </dd></dl>
<p>If you are using a <a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a3c8689767a0edbccf8ff7181f7b0af9b" title="Search the R-tree for all elements whose bounding boxes overlap a_rect. ">Search()</a> that uses a resultCallback() function, then return true to keep searching and false to terminate the search. </p>

</div>
</div>
<a id="a178196eaa2fd6ca8317f62a13d853817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178196eaa2fd6ca8317f62a13d853817">&#9670;&nbsp;</a></span>Search() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d46/struct_o_n___r_tree_capsule.html">ON_RTreeCapsule</a> *&#160;</td>
          <td class="paramname"><em>a_capsule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93488df03e8d43bf059881bb2dcfba93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93488df03e8d43bf059881bb2dcfba93">&#9670;&nbsp;</a></span>Search() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dce/struct_o_n___r_tree_b_box.html">ON_RTreeBBox</a> *&#160;</td>
          <td class="paramname"><em>a_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a384a71567ae0e7f0b55acd0548fb1fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384a71567ae0e7f0b55acd0548fb1fd6">&#9670;&nbsp;</a></span>Search() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_plane_eqn</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the R-tree for all elements whose bounding boxes overlap the set of points between to parallel planes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_plane_eqn</td><td>[in]</td></tr>
    <tr><td class="paramname">a_min</td><td>[in]</td></tr>
    <tr><td class="paramname">a_max</td><td>[in] The region between the parallel planes is the set point points where the value of the plane equation is &gt;= a_min and &lt;= a_max.</td></tr>
    <tr><td class="paramname">resultCallback</td><td>[in] A function to call when leaf nodes overlap the region between the parallel planes.</td></tr>
    <tr><td class="paramname">a_context</td><td>[in] pointer passed to the resultCallback() function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entire tree was searched. It is possible no results were found. </dd></dl>
<p>If you are using a <a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a3c8689767a0edbccf8ff7181f7b0af9b" title="Search the R-tree for all elements whose bounding boxes overlap a_rect. ">Search()</a> that uses a resultCallback() function, then return true to keep searching and false to terminate the search. </p>

</div>
</div>
<a id="aeb48a60f59ea578c30939e1c45d1829e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb48a60f59ea578c30939e1c45d1829e">&#9670;&nbsp;</a></span>Search() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="../../dd/d89/class_o_n___plane_equation.html">ON_PlaneEquation</a> &amp;&#160;</td>
          <td class="paramname"><em>a_plane_eqn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4f871f48b5e1ad3deeb8ac1b95921f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f871f48b5e1ad3deeb8ac1b95921f9">&#9670;&nbsp;</a></span>Search() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14df7f1392e2f2c98ad5d4ced530187e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14df7f1392e2f2c98ad5d4ced530187e">&#9670;&nbsp;</a></span>Search() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d7d/struct_o_n___r_tree_search_result.html">ON_RTreeSearchResult</a> &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad04555e76f86ddd5359ceb6948a7df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad04555e76f86ddd5359ceb6948a7df7">&#9670;&nbsp;</a></span>Search() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="../../db/d66/struct_o_n___r_tree_leaf.html">ON_RTreeLeaf</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b2149ea0203541285b3d5ca3c2c57c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2149ea0203541285b3d5ca3c2c57c3">&#9670;&nbsp;</a></span>Search() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae18942534add216538d971d266ef62f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18942534add216538d971d266ef62f3">&#9670;&nbsp;</a></span>Search() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89495554a3643a1ceccf18fc3de4028f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89495554a3643a1ceccf18fc3de4028f">&#9670;&nbsp;</a></span>Search() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rtreeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rtreeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; ON_2dex &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search two R-trees for all pairs elements whose bounding boxes overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_rtreeA</td><td>[in]</td></tr>
    <tr><td class="paramname">a_rtreeB</td><td>[in]</td></tr>
    <tr><td class="paramname">tolerance</td><td>[in] If the distance between a pair of bounding boxes is &lt;= tolerance, then the pair is added to a_result[].</td></tr>
    <tr><td class="paramname">a_result</td><td>[out] Pairs of ids of elements who bounding boxes overlap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entire tree was searched. It is possible no results were found. </dd></dl>
<p>If you have a single R-tree and you want to find paris of distinct nodes whose bounding boxes overlap, then use the non-static <a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a3c8689767a0edbccf8ff7181f7b0af9b" title="Search the R-tree for all elements whose bounding boxes overlap a_rect. ">ON_RTree::Search</a>(double tolerance, ... results ) member functions. </p>

</div>
</div>
<a id="a305a82abc47dd0a6ea8ee89b06cf37da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305a82abc47dd0a6ea8ee89b06cf37da">&#9670;&nbsp;</a></span>Search() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rtreeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rtreeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search two R-trees for all pairs elements whose bounding boxes overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_rtreeA</td><td>[in]</td></tr>
    <tr><td class="paramname">a_rtreeB</td><td>[in]</td></tr>
    <tr><td class="paramname">tolerance</td><td>[in] If the distance between a pair of bounding boxes is &lt;= tolerance, then resultCallback() is called.</td></tr>
    <tr><td class="paramname">resultCallback</td><td>[out] callback function</td></tr>
    <tr><td class="paramname">a_context</td><td>[in] argument passed through to resultCallback().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entire tree was searched. It is possible no results were found. </dd></dl>
<p>If you have a single R-tree and you want to find paris of distinct nodes whose bounding boxes overlap, then use the non-static <a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a3c8689767a0edbccf8ff7181f7b0af9b" title="Search the R-tree for all elements whose bounding boxes overlap a_rect. ">ON_RTree::Search</a>(double tolerance, ... results ) member functions. </p>

</div>
</div>
<a id="a81130c40694f16ecc2cf8e1652972454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81130c40694f16ecc2cf8e1652972454">&#9670;&nbsp;</a></span>Search() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rtreeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rtreeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search two R-trees for all pairs elements whose bounding boxes overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_rtreeA</td><td>[in]</td></tr>
    <tr><td class="paramname">a_rtreeB</td><td>[in]</td></tr>
    <tr><td class="paramname">tolerance</td><td>[in] If the distance between a pair of bounding boxes is &lt;= tolerance, then resultCallback() is called.</td></tr>
    <tr><td class="paramname">resultCallback</td><td>[out] callback function Return true for the search to continue and false to terminate the search.</td></tr>
    <tr><td class="paramname">a_context</td><td>[in] argument passed through to resultCallback().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entire tree was searched. It is possible no results were found. </dd></dl>
<p>If you have a single R-tree and you want to find paris of distinct nodes whose bounding boxes overlap, then use the non-static <a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a3c8689767a0edbccf8ff7181f7b0af9b" title="Search the R-tree for all elements whose bounding boxes overlap a_rect. ">ON_RTree::Search</a>(double tolerance, ... results ) member functions. </p>

</div>
</div>
<a id="ac293e6ba656ac6e792f4c577fb0d98c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac293e6ba656ac6e792f4c577fb0d98c8">&#9670;&nbsp;</a></span>Search() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rtreeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> &amp;&#160;</td>
          <td class="paramname"><em>a_rtreeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB, double *tolerance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search two R-trees for all pairs elements whose bounding boxes overlap. The tolerance can be reduced by the callback function during the search. This version of search is well suited to finding closest points between two objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_rtreeA</td><td>[in]</td></tr>
    <tr><td class="paramname">a_rtreeB</td><td>[in]</td></tr>
    <tr><td class="paramname">tolerance</td><td>[in] If the distance between a pair of bounding boxes is &lt;= tolerance, then resultCallback() is called.</td></tr>
    <tr><td class="paramname">resultCallback</td><td>[out] callback function Return true for the search to continue and false to terminate the search. The callback may reduce the value of the tolerance parameter during the search. Increasing the value of the tolerance or setting it to an invalid value is not supported and will lead to unpredictable results.</td></tr>
    <tr><td class="paramname">a_context</td><td>[in] argument passed through to resultCallback().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entire tree was searched. It is possible no results were found. </dd></dl>
<p>If you have a single R-tree and you want to find paris of distinct nodes whose bounding boxes overlap, then use the non-static <a class="el" href="../../dc/d3e/class_o_n___r_tree.html#a3c8689767a0edbccf8ff7181f7b0af9b" title="Search the R-tree for all elements whose bounding boxes overlap a_rect. ">ON_RTree::Search</a>(double tolerance, ... results ) member functions. </p>

</div>
</div>
<a id="a691a5c09301cf8a7f869f762f9b51dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691a5c09301cf8a7f869f762f9b51dc8">&#9670;&nbsp;</a></span>Search() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; ON_2dex &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a single R-tree for all pairs of distinct elements whose bounding boxes overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>[in] If the distance between a pair of bounding boxes is &lt;= tolerance, then the pair is added to a_result[].</td></tr>
    <tr><td class="paramname">a_result</td><td>[out] Pairs of ids of elements who bounding boxes overlap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entire tree was searched. It is possible no results were found. </dd></dl>

</div>
</div>
<a id="a7cffce7ab9b169a55f95f5a305299531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cffce7ab9b169a55f95f5a305299531">&#9670;&nbsp;</a></span>Search() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a single R-tree for all pairs of distinct elements whose bounding boxes overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>[in] If the distance between a pair of bounding boxes is &lt;= tolerance, then resultCallback() is called.</td></tr>
    <tr><td class="paramname">resultCallback</td><td>[out] callback function</td></tr>
    <tr><td class="paramname">a_context</td><td>[in] argument passed through to resultCallback().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entire tree was searched. It is possible no results were found. </dd></dl>

</div>
</div>
<a id="a7ce5797e0f24dcfe60e4cb5d2a305551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce5797e0f24dcfe60e4cb5d2a305551">&#9670;&nbsp;</a></span>Search() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a single R-tree for all pairs of distinct elements whose bounding boxes overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>[in] If the distance between a pair of bounding boxes is &lt;= tolerance, then resultCallback() is called.</td></tr>
    <tr><td class="paramname">resultCallback</td><td>[out] callback function</td></tr>
    <tr><td class="paramname">a_context</td><td>[in] argument passed through to resultCallback().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entire tree was searched. It is possible no results were found. </dd></dl>

</div>
</div>
<a id="ae86bf57453293f572bb791c449b23cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86bf57453293f572bb791c449b23cdb">&#9670;&nbsp;</a></span>Search() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB, double *tolerance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search a single R-tree for all pairs of distinct elements whose bounding boxes overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>[in] If the distance between a pair of bounding boxes is &lt;= tolerance, then resultCallback() is called.</td></tr>
    <tr><td class="paramname">resultCallback</td><td>[out] callback function Return true for the search to continue and false to terminate the search. The callback may reduce the value of the tolerance parameter during the search. Increasing the value of the tolerance or setting it to an invalid value is not supported and will lead to unpredictable results.</td></tr>
    <tr><td class="paramname">a_context</td><td>[in] argument passed through to resultCallback().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entire tree was searched. It is possible no results were found. </dd></dl>

</div>
</div>
<a id="a25b64597a8b7cb18ec70db91613bc198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b64597a8b7cb18ec70db91613bc198">&#9670;&nbsp;</a></span>Search2d() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search2d </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool ON_CALLBACK_CDECL &#160;</td>
          <td class="paramname"><em>resultCallback</em>void *a_context, ON__INT_PTR a_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a183fe6167390c34f7ddf4346c815d3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183fe6167390c34f7ddf4346c815d3f3">&#9670;&nbsp;</a></span>Search2d() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search2d </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d7d/struct_o_n___r_tree_search_result.html">ON_RTreeSearchResult</a> &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac12daf0578b650d8fb176c6bfd0551ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12daf0578b650d8fb176c6bfd0551ea">&#9670;&nbsp;</a></span>Search2d() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search2d </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="../../db/d66/struct_o_n___r_tree_leaf.html">ON_RTreeLeaf</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0796e641e7182e2627dc603934de7cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0796e641e7182e2627dc603934de7cac">&#9670;&nbsp;</a></span>Search2d() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search2d </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4385c53c34dcf30080c8db40417352d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4385c53c34dcf30080c8db40417352d2">&#9670;&nbsp;</a></span>Search2d() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_RTree::Search2d </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_min</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a_max</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafee383d7c1af961a7608376d7ce7154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafee383d7c1af961a7608376d7ce7154">&#9670;&nbsp;</a></span>SizeOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_RTree::SizeOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of heap memory used by this R-tree. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a195f4a9b64b621cf180e09efd53fbe82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195f4a9b64b621cf180e09efd53fbe82">&#9670;&nbsp;</a></span>Empty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d3e/class_o_n___r_tree.html">ON_RTree</a> ON_RTree::Empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
</div> <!-- page-content -->
</div> <!-- container -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 2 2018 07:57:31 for openNURBS SDK Help by <a href="http://www.doxygen.org/index.html">
<!-- <img class="footer" src="../../doxygen.png" alt="doxygen"/> -->
Doxygen
</a> 1.8.13
</small></address>
<script type="text/javascript" src="../../doxy-boot.js"></script>
</body>
</html>
